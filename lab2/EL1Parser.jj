// This is supporting software for CS321/CS322 Compilers and Language Design.
// Copyright (c) Portland State University
//
// EL1 parser specification. (For CS322, Jingke Li)
//
//
PARSER_BEGIN(EL1Parser)
import java.io.*;

public class EL1Parser {
  public static void main(String [] args) throws Exception {
    if (args.length == 1) {
    	FileInputStream stream = new FileInputStream(args[0]);
    	EL1.Exp prog = new EL1Parser(stream).Program();
    	stream.close();
    	System.out.println(prog);
    } else {
    	System.out.println("Need a file name as command-line argument.");
    }
  }
}
PARSER_END(EL1Parser)

SKIP: 
{
  " " | "\t" | "\r" | "\f" | "\n"
| <COMMENT: "#" (~["\n","\r"])* ("\n"|"\r"|"\r\n")> 
}

TOKEN: 
{
  "let" | "in" | "end" | "fn"
}

TOKEN: 
{
  <#Digit:   ["0"-"9"]>
| <#Letter:  ["A"-"Z"]|["a"-"z"]>
| <Num:      (<Digit>)+> 
| <Var:      <Letter> (<Letter>|<Digit>)*>
}

// Program -> Exp
//
EL1.Exp Program():
{ EL1.Exp e; }
{
  e=Exp(null) <EOF> { return e; }
}

// Exp -> fn var => Exp
//     |  Factor [+ Exp]
//
EL1.Exp Exp(EL1.Exp e0):
{ EL1.Exp e;
  EL1.Var var; }
{
  ( "fn" var=Var() "=>" e=Exp(null) { e = new EL1.Func(var,e); }
  | e=Factor(null) { if (e0 != null) e = new EL1.Plus(e0,e); }
    [ "+" e=Exp(e) ] 
  )
  { return e; }
}

// Factor -> Base [Factor]
//
EL1.Exp Factor(EL1.Exp e0):
{ EL1.Exp e;
  EL1.Var var; }
{
  e=Base() { if (e0 != null) e = new EL1.Call(e0,e); }
  [ e=Factor(e) ] 
  { return e; }
}

// Base -> let var = Exp in Exp end
//      |  ( Exp )
//      |  var
//      |  num
//
EL1.Exp Base():
{ EL1.Exp e, e1, e2;
  EL1.Var var; 
  EL1.Num num; }
{
  ( "let" var=Var() "=" e1=Exp(null) "in" e2=Exp(null) "end"
    { e = new EL1.Let(var,e1,e2); }
  | "(" e=Exp(null) ")"
  | e=Var()
  | e=Num() 
  )
  { return e; }
}


EL1.Var Var():
{ Token t; }
{
  t=<Var> { return new EL1.Var(t.image); }
}

EL1.Num Num():
{ Token t; }
{
  t=<Num> { return new EL1.Num(Integer.parseInt(t.image)); }
}


